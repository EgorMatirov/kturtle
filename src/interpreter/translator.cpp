/*
	Copyright (C) 2003-2006 Cies Breijs <cies # kde ! nl>

	This program is free software; you can redistribute it and/or
	modify it under the terms of version 2 of the GNU General Public
	License as published by the Free Software Foundation.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public
	License along with this program; if not, write to the Free
	Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
	Boston, MA 02110-1301, USA.
*/


#include <QDomDocument>
#include <QFile>

#include <QtDebug>


#include "token.h"

#include "translator.h"


Translator* Translator::m_instance = 0;  // initialize pointer

Translator* Translator::instance()
{
	if (m_instance == 0) m_instance = new Translator;  // create sole instance if its the first call
	return m_instance;  // address of sole instance
}


Translator::Translator()
{
// 	QString dictFile = QString(":interpreter/resources/KTurtleDictionary.en_US.xml");
// 	
// 	qDebug() << "Trying to load dictionary: " << dictFile;
// 	bool loaded = loadDictionary(dictFile);
// 	qDebug() << (loaded ? "Dictionary loaded" : "Error while loading dictionary") << "\n\n";
}

Translator::~Translator()
{
	delete m_instance;
	m_instance = 0;
}

bool Translator::loadDictionary(const QString &xmlFile) {
	QFile dictionaryFile(xmlFile);
	QDomDocument dictionary;

	if (!dictionaryFile.open(QIODevice::ReadOnly)) {
		 qDebug() << "Cannot open dictionary file...\n";
		 return false;
	}
	
	if (!dictionary.setContent(&dictionaryFile)) {
		// maybe an XML document validation here ;)
		QString errMsg;
		int row;
		int col;
		dictionary.setContent(&dictionaryFile, &errMsg, &row, &col );
		qDebug() << "Problem loading the dictionary: " << errMsg << " @ (" << row << ", " << col << ")\n";
		dictionaryFile.close();
		return false;
	}
	dictionaryFile.close();

	// get into the first child of the root element (in our case a <command> tag)
	QDomElement rootElement  = dictionary.documentElement();
	QDomNode    tokenElement = rootElement.firstChild();

	while (!tokenElement.isNull()) {
		if (tokenElement.toElement().tagName() == "token") {  // skip unkown tags like comments
			QString tokenType, look;
			tokenType = tokenElement.toElement().attribute("type"); // get the name attribute of <token>
			QDomNode lookElement = tokenElement.firstChild(); // get into the first child of a <token>
			while (!lookElement.isNull()) {
				if (lookElement.toElement().tagName() == "look") {
					look = lookElement.toElement().text();
// 					qDebug(QString("%1 [%2] -- %3").arg(look).arg(stringType2intType(tokenType)).arg(tokenType).toLatin1());
					look2typeMap.insert(look, stringType2intType(tokenType));
				}
				lookElement = lookElement.nextSibling(); // goto the next element in the current <command>
			}
		}
		tokenElement = tokenElement.nextSibling(); // goto the next <command>
	}
	return true;
}

int Translator::look2type(QString& look) {
	if (look2typeMap.contains(look))
		return look2typeMap[look];
	return Token::Unknown;
}

int Translator::look2type(QChar& look) {
	if (look2typeMap.contains(static_cast<QString>(look)))
		return look2typeMap[static_cast<QString>(look)];
	return Token::Unknown;
}

QList<QString> Translator::type2look(int type)
{
	return look2typeMap.keys(type);
}

QHash<int, QList<QString> > Translator::token2stringsMap()
{
	QHash<int, QList<QString> > resultMap;
	QList<int> tokenList = look2typeMap.values();
	foreach (int token, tokenList) resultMap.insert(token, look2typeMap.keys(token));
	return resultMap;
}



int Translator::stringType2intType(QString typeString) {

//BEGIN GENERATED translator_cpp CODE

/* The code between the line that start with "//BEGIN GENERATED" and "//END GENERATED"
 * is generated by "generate.rb" according to the definitions specified in
 * "definitions.rb". Please make all changes in the "definitions.rb" file, since all
 * all change you make here will be overwritten the next time "generate.rb" is run.
 * Thanks for looking at the code!
 */

	if (typeString == "NotSet")             return Token::NotSet;
	if (typeString == "Unknown")            return Token::Unknown;
	if (typeString == "Error")              return Token::Error;
	if (typeString == "Root")               return Token::Root;
	if (typeString == "Scope")              return Token::Scope;
	if (typeString == "WhiteSpace")         return Token::WhiteSpace;
	if (typeString == "EndOfLine")          return Token::EndOfLine;
	if (typeString == "EndOfFile")          return Token::EndOfFile;
	if (typeString == "VariablePrefix")     return Token::VariablePrefix;
	if (typeString == "Variable")           return Token::Variable;
	if (typeString == "FunctionCall")       return Token::FunctionCall;
	if (typeString == "String")             return Token::String;
	if (typeString == "Number")             return Token::Number;
	if (typeString == "True")               return Token::True;
	if (typeString == "False")              return Token::False;
	if (typeString == "Comment")            return Token::Comment;
	if (typeString == "StringDelimiter")    return Token::StringDelimiter;
	if (typeString == "ScopeOpen")          return Token::ScopeOpen;
	if (typeString == "ScopeClose")         return Token::ScopeClose;
	if (typeString == "ParenthesisOpen")    return Token::ParenthesisOpen;
	if (typeString == "ParenthesisClose")   return Token::ParenthesisClose;
	if (typeString == "ArgumentSeparator")  return Token::ArgumentSeparator;
	if (typeString == "DecimalSeparator")   return Token::DecimalSeparator;
	if (typeString == "Exit")               return Token::Exit;
	if (typeString == "If")                 return Token::If;
	if (typeString == "Else")               return Token::Else;
	if (typeString == "Repeat")             return Token::Repeat;
	if (typeString == "While")              return Token::While;
	if (typeString == "For")                return Token::For;
	if (typeString == "ForTo")              return Token::ForTo;
	if (typeString == "To")                 return Token::To;
	if (typeString == "Step")               return Token::Step;
	if (typeString == "Break")              return Token::Break;
	if (typeString == "Return")             return Token::Return;
	if (typeString == "Wait")               return Token::Wait;
	if (typeString == "And")                return Token::And;
	if (typeString == "Or")                 return Token::Or;
	if (typeString == "Not")                return Token::Not;
	if (typeString == "Equals")             return Token::Equals;
	if (typeString == "NotEquals")          return Token::NotEquals;
	if (typeString == "GreaterThan")        return Token::GreaterThan;
	if (typeString == "LessThan")           return Token::LessThan;
	if (typeString == "GreaterOrEquals")    return Token::GreaterOrEquals;
	if (typeString == "LessOrEquals")       return Token::LessOrEquals;
	if (typeString == "Addition")           return Token::Addition;
	if (typeString == "Substracton")        return Token::Substracton;
	if (typeString == "Multiplication")     return Token::Multiplication;
	if (typeString == "Division")           return Token::Division;
	if (typeString == "Power")              return Token::Power;
	if (typeString == "Assign")             return Token::Assign;
	if (typeString == "Learn")              return Token::Learn;
	if (typeString == "ArgumentList")       return Token::ArgumentList;
	if (typeString == "Reset")              return Token::Reset;
	if (typeString == "Clear")              return Token::Clear;
	if (typeString == "Center")             return Token::Center;
	if (typeString == "Go")                 return Token::Go;
	if (typeString == "GoX")                return Token::GoX;
	if (typeString == "GoY")                return Token::GoY;
	if (typeString == "Forward")            return Token::Forward;
	if (typeString == "Backward")           return Token::Backward;
	if (typeString == "Direction")          return Token::Direction;
	if (typeString == "TurnLeft")           return Token::TurnLeft;
	if (typeString == "TurnRight")          return Token::TurnRight;
	if (typeString == "PenWidth")           return Token::PenWidth;
	if (typeString == "PenUp")              return Token::PenUp;
	if (typeString == "PenDown")            return Token::PenDown;
	if (typeString == "PenColor")           return Token::PenColor;
	if (typeString == "CanvasColor")        return Token::CanvasColor;
	if (typeString == "CanvasSize")         return Token::CanvasSize;
	if (typeString == "SpriteShow")         return Token::SpriteShow;
	if (typeString == "SpriteHide")         return Token::SpriteHide;
	if (typeString == "Print")              return Token::Print;
	if (typeString == "FontSize")           return Token::FontSize;
	if (typeString == "Random")             return Token::Random;

//END GENERATED translator_cpp CODE

	return Token::Unknown;
}
