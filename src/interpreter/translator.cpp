/*
	Copyright (C) 2003-2006 Cies Breijs <cies AT kde DOT nl>

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public
	License along with this program; if not, write to the Free
	Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
	Boston, MA 02110-1301, USA.
*/

#include "translator.h"

#include "token.h"


Translator* Translator::m_instance = 0;  // initialize pointer

Translator* Translator::instance()
{
	if (m_instance == 0) m_instance = new Translator;  // create sole instance if its the first call
	return m_instance;  // address of sole instance
}

Translator::Translator()
	: localizer(QStringList() << DEFAULT_LANGUAGE_CODE)
{
}

Translator::~Translator()
{
	delete m_instance;
	m_instance = 0;
}


int Translator::look2type(QString& look)
{
	if (look2typeMap.contains(look))
		return look2typeMap[look];
	return Token::Unknown;
}

int Translator::look2type(QChar& look)
{
	if (look2typeMap.contains(static_cast<QString>(look)))
		return look2typeMap[static_cast<QString>(look)];
	return Token::Unknown;
}

QList<QString> Translator::type2look(int type)
{
	return look2typeMap.keys(type);
}

QHash<int, QList<QString> > Translator::token2stringsMap()
{
	QHash<int, QList<QString> > resultMap;
	QList<int> tokenList = look2typeMap.values();
	foreach (int token, tokenList) resultMap.insert(token, look2typeMap.keys(token));
	return resultMap;
}


bool Translator::setLanguage(const QString &lang_code)
{
	// FIXME default to GUI language? return false when language not available?
	localizer = QStringList() << lang_code << DEFAULT_LANGUAGE_CODE;

	setDictionary();
	setExamples();

	return true;
}


void Translator::setDictionary()
{
	look2typeMap.clear();
	default2localizedMap.clear();

	QString localizedCommandLook;


//BEGIN GENERATED translator_cpp CODE

/* The code between the line that start with "//BEGIN GENERATED" and "//END GENERATED"
 * is generated by "generate.rb" according to the definitions specified in
 * "definitions.rb". Please make all changes in the "definitions.rb" file, since all
 * all change you make here will be overwritten the next time "generate.rb" is run.
 * Thanks for looking at the code!
 */

	look2typeMap["$"] = Token::VariablePrefix;

	localizedCommandLook = "true";
	default2localizedMap["true"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::True;

	localizedCommandLook = "false";
	default2localizedMap["false"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::False;

	look2typeMap["#"] = Token::Comment;

	look2typeMap["\""] = Token::StringDelimiter;

	look2typeMap["{"] = Token::ScopeOpen;

	look2typeMap["}"] = Token::ScopeClose;

	look2typeMap["("] = Token::ParenthesisOpen;

	look2typeMap[")"] = Token::ParenthesisClose;

	localizedCommandLook = ",";
	default2localizedMap[","] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::ArgumentSeparator;

	localizedCommandLook = ".";
	default2localizedMap["."] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::DecimalSeparator;

	localizedCommandLook = "exit";
	default2localizedMap["exit"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::Exit;

	localizedCommandLook = "if";
	default2localizedMap["if"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::If;

	localizedCommandLook = "else";
	default2localizedMap["else"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::Else;

	localizedCommandLook = "repeat";
	default2localizedMap["repeat"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::Repeat;

	localizedCommandLook = "while";
	default2localizedMap["while"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::While;

	localizedCommandLook = "for";
	default2localizedMap["for"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::For;

	localizedCommandLook = "to";
	default2localizedMap["to"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::To;

	localizedCommandLook = "step";
	default2localizedMap["step"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::Step;

	localizedCommandLook = "break";
	default2localizedMap["break"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::Break;

	localizedCommandLook = "return";
	default2localizedMap["return"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::Return;

	localizedCommandLook = "wait";
	default2localizedMap["wait"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::Wait;

	localizedCommandLook = "assert";
	default2localizedMap["assert"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::Assert;

	localizedCommandLook = "and";
	default2localizedMap["and"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::And;

	localizedCommandLook = "or";
	default2localizedMap["or"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::Or;

	localizedCommandLook = "not";
	default2localizedMap["not"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::Not;

	look2typeMap["=="] = Token::Equals;

	look2typeMap["!="] = Token::NotEquals;

	look2typeMap[">"] = Token::GreaterThan;

	look2typeMap["<"] = Token::LessThan;

	look2typeMap[">="] = Token::GreaterOrEquals;

	look2typeMap["<="] = Token::LessOrEquals;

	look2typeMap["+"] = Token::Addition;

	look2typeMap["-"] = Token::Substracton;

	look2typeMap["*"] = Token::Multiplication;

	look2typeMap["/"] = Token::Division;

	look2typeMap["^"] = Token::Power;

	look2typeMap["="] = Token::Assign;

	localizedCommandLook = "learn";
	default2localizedMap["learn"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::Learn;

	localizedCommandLook = "reset";
	default2localizedMap["reset"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::Reset;

	localizedCommandLook = "clear";
	default2localizedMap["clear"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::Clear;

	localizedCommandLook = "ccl";
	default2localizedMap["ccl"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::Clear;

	localizedCommandLook = "center";
	default2localizedMap["center"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::Center;

	localizedCommandLook = "go";
	default2localizedMap["go"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::Go;

	localizedCommandLook = "gox";
	default2localizedMap["gox"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::GoX;

	localizedCommandLook = "gx";
	default2localizedMap["gx"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::GoX;

	localizedCommandLook = "goy";
	default2localizedMap["goy"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::GoY;

	localizedCommandLook = "gy";
	default2localizedMap["gy"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::GoY;

	localizedCommandLook = "forward";
	default2localizedMap["forward"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::Forward;

	localizedCommandLook = "fw";
	default2localizedMap["fw"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::Forward;

	localizedCommandLook = "backward";
	default2localizedMap["backward"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::Backward;

	localizedCommandLook = "bw";
	default2localizedMap["bw"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::Backward;

	localizedCommandLook = "direction";
	default2localizedMap["direction"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::Direction;

	localizedCommandLook = "dir";
	default2localizedMap["dir"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::Direction;

	localizedCommandLook = "turnleft";
	default2localizedMap["turnleft"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::TurnLeft;

	localizedCommandLook = "tl";
	default2localizedMap["tl"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::TurnLeft;

	localizedCommandLook = "turnright";
	default2localizedMap["turnright"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::TurnRight;

	localizedCommandLook = "tr";
	default2localizedMap["tr"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::TurnRight;

	localizedCommandLook = "penwidth";
	default2localizedMap["penwidth"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::PenWidth;

	localizedCommandLook = "pw";
	default2localizedMap["pw"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::PenWidth;

	localizedCommandLook = "penup";
	default2localizedMap["penup"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::PenUp;

	localizedCommandLook = "pu";
	default2localizedMap["pu"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::PenUp;

	localizedCommandLook = "pendown";
	default2localizedMap["pendown"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::PenDown;

	localizedCommandLook = "pd";
	default2localizedMap["pd"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::PenDown;

	localizedCommandLook = "pencolor";
	default2localizedMap["pencolor"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::PenColor;

	localizedCommandLook = "pc";
	default2localizedMap["pc"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::PenColor;

	localizedCommandLook = "canvascolor";
	default2localizedMap["canvascolor"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::CanvasColor;

	localizedCommandLook = "cc";
	default2localizedMap["cc"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::CanvasColor;

	localizedCommandLook = "canvassize";
	default2localizedMap["canvassize"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::CanvasSize;

	localizedCommandLook = "cs";
	default2localizedMap["cs"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::CanvasSize;

	localizedCommandLook = "spriteshow";
	default2localizedMap["spriteshow"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::SpriteShow;

	localizedCommandLook = "ss";
	default2localizedMap["ss"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::SpriteShow;

	localizedCommandLook = "spritehide";
	default2localizedMap["spritehide"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::SpriteHide;

	localizedCommandLook = "sh";
	default2localizedMap["sh"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::SpriteHide;

	localizedCommandLook = "print";
	default2localizedMap["print"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::Print;

	localizedCommandLook = "fontsize";
	default2localizedMap["fontsize"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::FontSize;

	localizedCommandLook = "random";
	default2localizedMap["random"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::Random;

	localizedCommandLook = "rnd";
	default2localizedMap["rnd"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::Random;

	localizedCommandLook = "getx";
	default2localizedMap["getx"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::GetX;

	localizedCommandLook = "gety";
	default2localizedMap["gety"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::GetY;

	localizedCommandLook = "message";
	default2localizedMap["message"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::Message;

	localizedCommandLook = "ask";
	default2localizedMap["ask"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::Ask;

	localizedCommandLook = "pi";
	default2localizedMap["pi"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::Pi;

	localizedCommandLook = "tan";
	default2localizedMap["tan"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::Tan;

	localizedCommandLook = "sin";
	default2localizedMap["sin"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::Sin;

	localizedCommandLook = "cos";
	default2localizedMap["cos"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::Cos;

	localizedCommandLook = "arctan";
	default2localizedMap["arctan"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::ArcTan;

	localizedCommandLook = "arcsin";
	default2localizedMap["arcsin"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::ArcSin;

	localizedCommandLook = "arccos";
	default2localizedMap["arccos"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::ArcCos;

	localizedCommandLook = "sqrt";
	default2localizedMap["sqrt"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::Sqrt;

	localizedCommandLook = "round";
	default2localizedMap["round"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::Round;

	localizedCommandLook = "getdirection";
	default2localizedMap["getdirection"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::GetDirection;

	localizedCommandLook = "mod";
	default2localizedMap["mod"] = localizedCommandLook;
	look2typeMap[localizedCommandLook] = Token::Mod;


//END GENERATED translator_cpp CODE

}



void Translator::setExamples()
{
	examples.clear();
	QString exampleName;

	exampleName = "triangle";
	examples[exampleName] = localizeScript(QString(
				"@(reset)\n"
				"@(repeat) 3 {\n"
				"  @(forward) 100\n"
				"  @(turnleft) 120\n"
				"}\n"
		));

	exampleName = "curly";
	examples[exampleName] = localizeScript(QString(
				"@(reset)\n"
				"@(penup)\n"
				"@(forward) 50\n"
				"@(pendown)\n"
				"\n"
				"@(repeat) 4 {\n"
				"  @(for) $x = 1 @(to) 100 {\n"
				"    @(forward) 10\n"
				"    @(turnright) 100 - $x\n"
				"  }\n"
				"}\n"
		));

	exampleName = "arrow";
	examples[exampleName] = localizeScript(QString(
				"@(reset)\n"
				"\n"
				"@(canvassize) 200@(,) 200\n"
				"@(canvascolor) 0@(,) 0@(,) 0\n"
				"@(pencolor) 255@(,) 0@(,) 0\n"
				"@(penwidth) 5\n"
				"\n"
				"@(go) 20@(,)20\n"
				"@(direction) 135\n"
				"\n"
				"@(forward) 200\n"
				"@(turnleft) 135\n"
				"@(forward) 100\n"
				"@(turnleft) 135\n"
				"@(forward) 141\n"
				"@(turnleft) 135\n"
				"@(forward) 100\n"
				"@(turnleft) 45\n"
				"\n"
				"@(go) 40@(,) 100"
		));

	exampleName = "flower";
	examples[exampleName] = localizeScript(QString(
				"@(reset)\n"
				"@(canvascolor) 255@(,) 55@(,) 140\n"
				"@(pencolor) 160@(,) 0@(,) 255\n"
				"@(penwidth) 3\n"
				"\n"
				"@(repeat) 8 {\n"
				"  @(repeat) 4 {\n"
				"    @(forward) 20\n"
				"    @(turnright) 30\n"
				"  }\n"
				"  @(repeat) 7 {\n"
				"    @(forward) 10\n"
				"    @(turnright) 15\n"
				"  }\n"
				"  @(repeat) 9 {\n"
				"    @(forward) 3\n"
				"    @(turnright) 10\n"
				"  }\n"
				"}\n"
				"\n"
				"@(go) 145@(,) 145\n"
				"@(direction) 0"
		));

}

QString Translator::localizeScript(const QString& untranslatedScript)
{
	QString result = untranslatedScript;
	Translator* translator = Translator::instance();
	QRegExp rx("@\\(.*\\)");
	rx.setMinimal(true);  // make it not greedy

	int pos = 0;
	while ((pos = rx.indexIn(result, pos)) != -1) {
		QString original = result.mid(pos, rx.matchedLength());
		original = original.mid(2, original.length() - 3);
		result = result.replace(pos, rx.matchedLength(), translator->default2localized(original));
	}

	return result;
}
